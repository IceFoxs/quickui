<!--
An input area with a dropdown arrow, which invokes a popup.
-->

<Control name="ComboBox">

<prototype>
    <HasPopup>
        <content>
            <div id="ComboBox_content"/>
            <ToggleButton id="dropdownButton">&#9660;</ToggleButton>
        </content>
    </HasPopup>
</prototype>

<style>
{
    display: inline-table;
}

#HasPopup_content > * {
    display: table-cell;
}

#HasPopup_popup {
    -moz-outline: none;
}

#ComboBox_content input[type='text'] {
    border: none;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    outline: none;
    padding: 2px;
}

#dropdownButton {
    text-align: center;
    vertical-align: middle;
}

/* Generic appearance */
.ComboBox.generic {
    border: 1px solid lightgray;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
.ComboBox.generic #dropdownButton {
    border: none;
    padding: 0 0.25em; /* Tighter padding that normal */
}
</style>

<script>
ComboBox.prototype.extend({

    closeOnEnter: Control.property.bool( null, true ),
    content: Control.chain( "$ComboBox_content", "content" ),
    openOnFocus: Control.property.bool( null, true ),
    _handlingPopupClick: Control.property(),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ComboBox );
        
        var self = this;
        this.$HasPopup_popup().bind({
            "canceled": function() {
                self.$dropdownButton().selected( false );
            },
            "click": function() {
                // See notes at focusout handler below.
                self._handlingPopupClick( true );
            },
            "closed": function() {
                // Closing the popup leaves the text selected.
                // HACK for IE: If we set focus to the input while the popup is
                // being closed, IE won't hide the popup. It seems quite hard
                // to prevent this behavior, so we simply disable the selection
                // behavior in IE.
                if ( !$.browser.msie ) {
                    var content = self.content();
                    self.inputControl().focus();
                    self._selectText( 0, content.length );
                }
                self.$dropdownButton().selected( false );
                self._handlingPopupClick( false );
            }
        });
        
        this.bind({
            // Open the popup when any part of the control gets focus.
            "focusin": function( event ) {
                self._handlingPopupClick( false );
                if ( self.openOnFocus() && !self.opened() ) {
                    self.open();
                }
            },
            // Close the popup when the control loses focus.
            "focusout": function( event ) {
                /*
                 * We want to close the popup if the focus moves completely
                 * outside the combo box; i.e., is not within the input box or
                 * the popup. Unfortunately, if the user clicks in the popup,
                 * the input will blur before we've had a chance to even
                 * register the click. And at the point the blur handler here
                 * is invoked, there's no reliable way to determine where
                 * the focus is going to end up.
                 * 
                 * HACK: We close the popup in a timeout. If the user is
                 * clicking in the popup, we set a flag (see click handler,
                 * above). If the flag is set by the time the timeout completes,
                 * we assume the focus was lost due to the click -- i.e., we
                 * can ignore the loss of focus. Otherwise, we assume the
                 * focus has really been moved to another control, and close
                 * the popup. Relying on the timing of events this way is far
                 * too fragile, but many other strategies here have failed
                 * (especially cross-browser).
                 * 
                 * In defense, this blur behavior is meant as a clean-up step
                 * in the case where the user fails to make a choice or
                 * actively dismiss the popup; presumably, this situation won't
                 * come up all that often.
                 */
                if ( self.opened() ) {
                    setTimeout( function() {
                        if ( self._handlingPopupClick() ) {
                            // Focus probably lost due to click.
                            // Reset our flag which was tracking this.
                            self._handlingPopupClick( false );
                        } else  if ( self.opened() ) { // Still open?
                            self.cancel();
                        }
                    }, 200);
                }
            }
        });
        
        this.$dropdownButton().click( function() {
            self.open();
        });
        
        /*
        this.$HasPopup_popup()
            .prop( "tabindex", 0 )
            .css( "-moz-outline", "none" );
        */
       
        if ( !this.textBoxClass() ) {
            // Set a default text box class
            this.textBoxClass( TextBox );
        }
    },
    
    /*
     * Return the combo box's input control. By default we return the first
     * text input element in the content. Subclasses can override this to
     * point at a different element.
     */
    inputControl: function() {
        return this.$ComboBox_content().find( "input[type='text']" ).eq(0);
    },
    
    open: function() {
        if ( !this.opened() ) {
        
            if ( this.hasClass( "generic" ) ) {
                // Make popup at least as wide as content.
                this.eachControl( function( index, $control ) {
                    var width = $control.outerWidth();
                    this.$HasPopup_popup().css( "min-width", width + "px" );
                });
            }
            
            // User may have invoked popup by clicking in text box with
            // openOnFocus true, in which case we should ensure button looks
            // pressed while popup is open.
            this.$dropdownButton().selected( true );
            
        }
        return this._super();
    },

    /*
     * The class of the text box portion of the combo box.
     */
    textBoxClass: Control.property[ "class" ]( function( textBoxClass ) {
        
        this.$ComboBox_content().transmute( textBoxClass );
        
        // Rebind any content events we want to track.
        this._bindContentEvents();
    }),
    
    _bindContentEvents: function() {
        this._super();
        var self = this;
        this.$ComboBox_content().bind({
            "keydown": function( event ) {
                if ( event.which === 13 /* Enter key */
                    && self.closeOnEnter()
                    && self.$HasPopup_popup().opened() ) {
                    self.close();
                }
            }
        });
    },

    /*
     * Select the text at the indicated positions in the input control.
     */
    _selectText: function( start, end ) {
        
        var inputControl = this.inputControl()[0];
        if ( !inputControl ) {
            return; // Can't find input control.
        }
        
        if ( inputControl.setSelectionRange ) {
            // Mozilla/WebKit
            inputControl.setSelectionRange( start, end );
        } else if ( inputControl.createTextRange ) {
            // IE
            var range = inputControl.createTextRange();
            range.moveStart( "character", start );
            range.moveEnd( "character", end );
            range.select();
        }
    }

});
</script>

</Control>
