<!--
An input area with a dropdown arrow, which invokes a popup.
-->

<Control name="ComboBox">

<prototype>
    <HasPopup>
        <content>
            <div id="ComboBox_content"/>
            <ToggleButton id="dropdownButton">&#9660;</ToggleButton>
        </content>
    </HasPopup>
</prototype>

<style>
{
    display: inline-table;
}

#HasPopup_content > * {
    display: table-cell;
}

#ComboBox_content input[type='text'] {
    border: none;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    outline: none;
    padding: 2px;
}

#dropdownButton {
    text-align: center;
    vertical-align: middle;
}

/* Generic appearance */
.ComboBox.generic {
    border: 1px solid lightgray;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
.ComboBox.generic #dropdownButton {
    border: none;
    padding: 0 0.25em; /* Tighter padding that normal */
}
</style>

<script>
ComboBox.prototype.extend({

    closeOnEnter: Control.property.bool( null, true ),
    content: Control.chain( "$ComboBox_content", "content" ),
    openOnFocus: Control.property.bool( null, true ),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ComboBox );
        
        var self = this;
        this.$HasPopup_popup().bind({
            "closed canceled": function() {
                self.$dropdownButton().selected( false );
            }
        });
        this.$dropdownButton().click( function() {
            self.open();
        });
        
        if ( !this.textBoxClass() ) {
            // Set a default text box class
            this.textBoxClass( TextBox );
        }
    },
    
    /*
     * Return the combo box's input control. By default we return the first
     * text input element in the content. Subclasses can override this to
     * point at a different element.
     */
    inputControl: function() {
        return this.$ComboBox_content().find( "input[type='text']" ).eq(0);
    },
    
    open: function() {
        if ( !this.opened() ) {
        
            if ( this.hasClass( "generic" ) ) {
                // Make popup at least as wide as content.
                this.eachControl( function( index, $control ) {
                    var width = $control.outerWidth();
                    this.$HasPopup_popup().css( "min-width", width + "px" );
                });
            }
            
            // User may have invoked popup by clicking in text box with
            // openOnFocus true, in which case we should ensure button looks
            // pressed while popup is open.
            this.$dropdownButton().selected( true );
            
        }
        return this._super();
    },

    /*
     * The class of the text box portion of the combo box.
     */
    textBoxClass: Control.property[ "class" ]( function( textBoxClass ) {
        
        this.$ComboBox_content().transmute( textBoxClass );
        
        // Rebind any content events we want to track.
        this._bindContentEvents();
    }),
    
    _bindContentEvents: function() {
        
        this._super();
        
        var self = this;
        this.$ComboBox_content().bind({
            "keydown": function( event ) {
                if ( event.which === 13 /* Enter key */
                    && self.closeOnEnter()
                    && self.$HasPopup_popup().opened() ) {
                    self.close();
                }
            }
        });
        this.$ComboBox_content().find( "input" ).bind({
            "blur": function( event ) {
                /*
                 * We want to close the popup if the focus moves completely
                 * outside the combo box; i.e., is not within the input box or
                 * the popup. Unfortunately, if the user clicks in the popup,
                 * the input will blur before we've had a chance to even
                 * register the click. And at the point the blur handler here
                 * is invoked, document.activeElement may not be set yet,
                 * so we can't inspect it to see whether the focus is still
                 * inside the popup.
                 * 
                 * HACK: We close the popup in a timeout, trusting that any
                 * click within the popup will have completed by the time the
                 * timeout completes. Wish there were a better way to do this;
                 * relying on the timing of events this way is far too fragile.
                 * In defense, this blur behavior is meant as a clean-up step
                 * in the case where the user fails to make a choice or
                 * actively dismiss the popup; presumably, this situation won't
                 * come up all that often.
                 */
                if ( self.opened() ) {
                    setTimeout( function() {
                        self.cancel(); 
                    }, 250 );
                }
            },
            "click focus": function() {
                if ( self.openOnFocus() ) {
                    self.open();
                }
            }
        });
    }

});
</script>

</Control>
